# C_code learn
## 一维数组

### 一维数组的创建与初始化

#### 数组的创建
- 什么是数组？
  一组相同类型元素的集合

- 创建语法
  type_t arr_name [const_n]

  eg: `int arr[10]` `doube arr[10]` `doube arr[15 + 5]`

- 注意：
  - 在C99标准前，数组的大小必须是==常量==或==常量表达式==
  - 在C99标准后，数组的大小可以是==变量==，为了支持==变长数组==
对于默认不是C99标准的编译器，使用`-std = c99`来采用C99标准
  - 采用变量定义的数组是不能初始化的
  
#### 数组的初始化：
 在创建数组时赋予数组合理的值

##### 初始化种类：
- 不完全初始化
> int arr[==10==] = [==1, 2, 3==]
此数组中剩余元素默认初始化为==0==

- 
  `char arr[] = {"abc"}`中，元素有`a` `b` `c` `\0`
而`char arr[] = {'a', 'b', 'c'}`定义的数组中，元素只有`a` `b` `c`
字符串的结尾默认为`\0`

### 一维数组的使用
- 数组存储原理：在内存的一个栈区找到==连续的空间==进行存放
  
- 空间有编号，从零开始作为数组的下标
  
- 可以通过编号来快速提出元素
  
- `下标引用符`  `[ ]`采用`arr_name[ ]`来获取对应下标元素
  
- 可以采用`sizeof(arr)`来获取数组长度

### 一维数组在内存中的存储
一维数组在内存中连续存放

## 二维数组

### 二维数组的创建与初始化
#### 创建
eg:
> int arr[3][3];

- 第一栏为行数，可以为空，第二栏为列数，==不可为空==

#### 初始化
eg:
> int arr[4] [4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}

元素将会顺次填入数组，未填入按照不完全初始化来赋予0
>1 2 3 4
5 6 7 8
9 0 0 0
0 0 0 0


eg:
> int arr[4] [4] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}}
数组会按照内括号内容赋予数组每行值

| 一 | 二 | 三 | 四 |
| :---: |:---:|:---:|:---:|
| 1 | 2 | 0 | 0 |
| 3 | 4 | 0 | 0 |
| 5 | 6 | 0 | 0 |
| 7 | 8 | 0 | 0 |

上述都为不完全初始化

#### 元素定位：
通过行数列来定位，通过双重for循环来遍历打印所有元素

- 可以将二维数组视作`一维数组`的数组，每个元素是`一行一维数组`

#### 如何访问一行
`arr[a] [j]`

#### 二维数组的存放方式
- 二维数组在内存中依旧连续存放

### 数组越界：
数组的下标是有范围限制的

数组的下规定是从0开始的,如果数组有n个元素,最后一个元素的下标就是n-1。

所以数组的下标如果`小于0`,或者`大于n-1`,就是==数组越界访问==了,超出了数组合法空间的访问。

C语言本身是不做数组下标的越界检查,编译器也不一定报错,但是编译器不报错,并不意味着程序就

是正确的,

所以程序员写代码时,最好自己做`越界的检查`

### 将数组作为参数传递
 
 直接传递`数组名`，传递数组地址

 形参类型：

   - 数组接收（伪）：
  `int arr[]`
  这种写法传参并未将整个数组传递，而只是传递了数组的地址

  - 指针接收：
  
    - 更符合数组传递的本质
  
    - `int* p`

    后面p始终指向`首地址`

    若要调用`arr[i]`

    等价于`*(p + i)`

### 数组名

- 思考：如果数组名是首元素地址，那sizeof(arr)输出为`全数组字节数`？

  - 数组名确实是`首元素地址`

  - 存在两个例外
  
    1. sizeof()内数组名字为全数组大小(以字节为单位)
    
    2. `&arr_x`数组名表示整个`数组`而不是元素地址，整个数组从`首元素以地址为开始`

  - 如何思考`首元素地址`与`数组地址`区别
  
    数组名 + 1 == 跳过整个数组
    首元素 + 1 == 数组的下个元素

  - 二位数组的数组名

    二维数组的数组名也表示首元素的地址

    二维数组的首元素是`首行`而不是`[0] [0]元素`

  - 二维数组行数求法
  
    `sizeof(arr) / sizeof(arr[0])`

  - 二维数组列数求法
  
    `sizeof(arr[0]) / sizeof(arr[0] [0])`

### 项目练习

> 利用数组实现项目`三字棋`

> 利用数组实现项目`扫雷小游戏`

#### 三字棋

- 项目结构：
  
    - test.c :游戏逻辑测试
  
    - test.h :游戏逻辑测试声明

    - game.h:代码声明：

      包含函数声明，符号定义

### 逗号表达式
- 基本特性：
  
  从左到右依次计算各个表达式

  整个表达式的值是`最后一个表达式`的值

  `前 n-1 个表达式的值`会被丢弃（但副作用会保留）

- eg:
  arr[] = {1,2,(3,4),5};
  (3, 4)为一个逗号表达式，最后计算结果为4，只占用一个元素

### 只读变量

- 当我想使用变量来定义数组长度时
  
  可以尝试使用const确定的`只读变量`

  - eg：
    int x = num;
    const int* len = `&x`;  

  或者采用宏定义来确定

### 数组的类型
  
- 数组也是有类型的，数组的定义式去掉数组名即为数组的类型
  
  eg：
  int arr[10] 的类型为 `int [10]`

  同样也可以使用`sizeof`来求一个类型数组的长度


### `sizeof`与`strlen`的区别

- `sizeof`是==操作符==，用来计算变量（或类型所创建的变量）所占内存的大小,

  只关注内存的大小，不关注内存存放的具体内容

- `strlen`是==库函数==，专门用于求==字符串==的长度，只针对==字符串==，不包含`\0`
  
  从参数给到的地址一直找`\0`，统计直到`\0`前出现的字符的个数

